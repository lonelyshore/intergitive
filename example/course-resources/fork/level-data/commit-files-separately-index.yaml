asset_index:
  infile:
# course contents
    intro-goal: |+2
      .md
      在前一節之中我們介紹了在資料夾中新增**一個**檔案的時候，如何把「新增了檔案的資料夾」建立一份${{t/revision}}  
      那麼，當資料夾中新增了**多個**檔案的時候，又會有甚麼不同呢？讓我們來探索看看  

    add-new-files: |+2
      .md
      首先，我們需要在資料夾中新增幾個檔案才行  
      請按照前一節所教的技巧，在 `#{{basic}}` 資料夾中建立以下檔名的純文字檔案：  

      - new1
      - new2
      - new3
      - new4

      完成後，請按下「確認」按鈕來確認檔案有順利新增完成

    will-commit-separately: |+2
      .md
      完成新增檔案後，讓我們看看${{t/gui}}的${{st/changes-tab}}目前是甚麼狀態  
      請使用${{t/gui}}開啟 `#{{basic}}` 資料夾  
      然後，按照上一節所教的方法，切換到${{st/changes-tab}}  
      切換成功後，應該會出現如下圖(一)所示的畫面：

      ![illustration]({{images/four-dirty-work-tree}})  
      <div class="img-title">圖(一)</div>  

      可以看到，在上圖(一)紅框所圈選的${{st/unstaged-changes}}裡面有我們新增加的檔案們  
      接下來，讓我們嘗試一次只使用其中一個檔案來建立${{t/revision}}  

    stage-first: |+2
      .md
      請回想上一節的指示，並參照下圖(二-1)與圖(二-2)的步驟，將 `new1` 選入${{st/staged-changes}}  

      <div class="side-by-side-container">
        <div style="float: left;width: 46%;padding: 2%;">
          <img src="{{images/stage-new-one-only}}" alt="illustration">
          <div class="img-title">圖(二-1)</div>  
        </div>
        <div style="float: left;width: 46%;padding: 2%;">
          <img src="{{images/only-new-one-staged}}" alt="illustration">
          <div class="img-title">圖(二-2)</div>  
        </div>
      </div> 

      完成後，請按下「確認」按鈕來確認檔案有順利選入

    commit-first: |+2
      .md
      現在，我們確認 `new1` 處於${{st/staged-changes}}中  
      接下來，讓我們${{t/commit}}一份${{t/revision}}  

      請回想上一節的指示，並參照下圖(三)  
      將「${{level-data/commit-files-separately/first-commit-message}}」填入紅框圈選範圍  

      ![illustration]({{images/fill-commit-message-new-one}})  
      <div class="img-title">圖(三)</div>  

      輸入完成後，請按下上圖橘框圈選的「Commit 1 File」按鈕，完成${{t/commit}}的手續  

      請按下「確認」按鈕來確認${{t/revision}}順利建立  

    explain-separate-commit-by-index: |+2
      .md
      恭喜，我們又成功新增了一個${{t/revision}}  

      如果去瀏覽${{t/file-tree}}  
      你會發現雖然我們剛才在資料夾一口氣新增了四份新檔案，剛才新${{t/revision}}的${{t/file-tree}}裡面只有包含「new1」一個  
      也就是說，我們可以從複數的檔案變化裡面，只選取一部分來建立${{t/revision}}  

      這件事情 git 如何完成的呢？  
      實際上它正是透過上個章節最後介紹到的暫存區來達成  
      請讓我們用下面的圖(四-1)和圖(四-2)來說明這件事情  
      
      <div class="side-by-side-container">
        <div style="float: left;width: 46%;padding: 2%;">
          <img src="{{images/commi-separately-without-index}}" alt="illustration">
          <div class="img-title">圖(四-1)</div>  
        </div>
        <div style="float: left;width: 46%;padding: 2%;">
          <img src="{{images/commit-separately-with-index}}" alt="illustration">
          <div class="img-title">圖(四-2)</div>  
        </div>
      </div>  

      為了對照，先讓我們假設**並不存在**暫存區，也就是圖(四-1)所描述的情況  
      左邊的${{t/work-tree}}下面有一個黃色一個白色的檔案，代表目前新增加的檔案  
      當我們想要建立一份資料夾快照的時候，快照的對象直接就是${{t/work-tree}}
      所以，${{t/work-tree}}裡面的白色檔案和黃色檔案同時會被保存進同一個${{t/revision}}  

      相對的，圖(四-2)呈現實際上 git 的情況，存在一個中間的暫存區  
      左邊的${{t/work-tree}}下面同樣有一白一黃兩個檔案  
      不一樣的是，${{t/work-tree}}和${{t/repo}}之間多出了一個暫存區  

      當我們建立${{t/repo}}的一個新版本時，內容的來源是來自於暫存區而非${{t/work-tree}}  
      因為圖(四-2)中暫存區裡只有黃色檔案，所以最後建立的${{t/revision}}只有黃色而沒有白色檔案  
      實際上，這就正是剛才我們做的事情：從四個新檔案裏面，挑出「new1」放進暫存區，建立${{t/revision}}  

    introduce-index: |+2
      .md
      總結來說，多出暫存區的效果是，我們可以透過修改它的內容來控制所建立出來${{t/revision}}的內容  
      想像一下，當我們在工作的資料夾裡面產生了非常多的檔案(例如徹夜趕工所以改了很多東西)  
      如果這時候想要分批的建立版本快照，我們可以透過分批把檔案放進暫存區裡面來達成  

      因為暫存區有這樣重要的功能，它也有一個正式的名字
      那就是是**${{t/index-f}}**  

      在英文的文本中我們會見到幾個其它的用詞被交替使用，例如：cache, stage  
      在往後的章節中，我們統一使用**${{t/index}}**
      
      接下來，讓我們繼續藉由提交 new2 的變更來詳細解說如何控制**${{t/index}}**的內容

    stage-second: |+2
      .md
      請按照前面說明的方法，在${{t/gui}}的${{st/changes-tab}}中  
      使用「Stage」按鈕，將 `new2` 選入${{st/staged-changes}}  
      
      完成之後，請按下「確認」

    explain-stage: |+2
      .md
      現在， new2 已經存在於${{t/index}}之中了  

      我們是怎麼把 new2 放入${{t/index}}的呢？就是透過剛才操作的按鈕，**${{t/stage-f}}**  
      因此，我們知道${{t/stage}}的意思，就是把檔案從${{t/work-tree}}放入${{t/index}}  
      下圖(五)說明了這一操作  

      ![illustration]({{images/illustrate-stage-file-to-index}})  
      <div class="img-title">圖(五)</div>  

      這個操作完成後，在${{t/gui}}上會看到的現象，就是 new2 出現在${{st/staged-changes}}之中  
      恩...不過為什麼我們說檔案被放進了${{t/index-f}}中，${{t/gui}}卻用${{st/staged-changes}}來表現呢？  

      其實這兩者不完全相同，但是又互相有關聯  
      關於後者的意涵，我們會在之後解釋  
      目前我們只要知道${{t/stage}}的操作同時代表兩件事：  
      1. 把檔案從${{t/work-tree}}搬到${{t/index}}之中  
      2. 把檔案從${{t/unstaged-f}}的狀態，變成${{t/staged-f}}

      現在，讓我們繼續完成${{t/revision}}的${{t/commit}}~  

    commit-second: |+2
      .md
      請按照先前說明過的方法  
      輸入「`${{$level-data/commit-files-separately/second-commit-message}}`」作為提交訊息  
      然後提交${{t/revision}}  

      完成之後，請按下「確認」按鈕進行檢查  

    introduce-commit-multiple: |+2
      .md
      恭喜，我們又成功地把增加了 new2 的${{t/revision}}保存到了${{t/repo}}中  
      但是，在有很多檔案的情況下，一個一個地逐一添加實在是非常麻煩  
      有些時候，我們就是想要一口氣把所有檔案保存到${{t/repo}}中，又應該怎麼辦呢？  

      沒問題！請按照接下來的指引將剩下的 new3 和 new4 一網打盡吧！  

    stage-all: |+2
      .md
      請切換到${{t/gui}}的${{st/changes-tab}}  
      然後，如下圖(六-1)所示，按下紅框所圈選的，用來核選全部檔案的按鈕

      <div class="side-by-side-container">
        <div style="float: left;width: 46%;padding: 2%;">
          <img src="{{images/hint-click-stage-all}}" alt="illustration">
          <div class="img-title">圖(六-1)</div>  
        </div>
        <div style="float: left;width: 46%;padding: 2%;">
          <img src="{{images/clicked-stage-all}}" alt="illustration">
          <div class="img-title">圖(六-2)</div>  
        </div>
      </div>  

      按下之後，${{t/gui}}應該會變成如上圖(六-2)的狀態  
      從紅框圈選處，我們可以觀察到 new3 和 new4 兩個檔案都被列為${{t/staged}}  
      同時代表它們都被放入了${{t/index}}中
      
      這就表示，這時候${{t/commit-s}}一份${{t/revision}}，就會把他們同時保存進去  
      就讓我們繼續進行下去吧  

    commit-remain: |+2
      .md
      請將「${{$level-data/commit-files-separately/last-commit-message}}」作為提交訊息輸入  
      然後${{t/commit-s}}${{t/revision}}到${{t/repo}}  

      完成之後，請按下「確認」按鈕進行檢查  

    summary: |+2
      .md
      恭喜，我們完成了一次同時把兩個檔案加入到一份新${{t/revision}}的新壯舉  

      回顧一下這一個章節，我們學會了${{t/index}}可以用來分批建立${{t/revision}}  
      也認識了「${{t/stage}}」這個動作可以把檔案從${{t/work-tree}}搬入${{t/index}}之中  
      最後，還學到了可以一次將所有的檔案都搬入${{t/index}}的絕技  

      但是，到目前為止，我們都只知道如何保存新增加的檔案到${{t/repo}}之中  
      如果我們想要修改檔案又應該如何處理呢？請讓我們往下一個章節繼續看下去...



# course materials
    empty: ""
    first-commit-message: "增加new1"
    second-commit-message: "增加new2"
    last-commit-message: "增加new3與new4"